# 6.1 Creating a Deployment - 详细解读

## 一、概述

### 1.1 本节简介

本节是 LangChain Academy Module-6 的第一部分，标志着我们从**开发阶段进入生产部署阶段**。在 Module-5 中，我们创建了功能强大的 `task_maistro` 应用（任务管理助手），现在是时候将它部署到生产环境，让真实用户可以使用了。

### 1.2 什么是部署（Deployment）？

**部署**是将应用程序从开发环境移到生产环境的过程，使其能够：
- 24/7 全天候运行
- 处理多个并发用户
- 持久化存储数据
- 提供稳定的 API 接口
- 支持扩展和监控

**类比**：
```
开发环境（Development）          生产环境（Production）
    ↓                              ↓
在你的电脑上运行                  在服务器上运行
localhost:8000                   your-domain.com
只有你能访问                      所有用户都能访问
数据存储在内存中                  数据存储在数据库中
```

### 1.3 LangGraph Platform 架构

本节将介绍 **LangGraph Platform**，这是一个完整的部署解决方案：

```
┌──────────────────────────────────────────────────────┐
│          LangGraph Platform 架构                      │
├──────────────────────────────────────────────────────┤
│                                                       │
│  ┌──────────────┐   ┌──────────────┐   ┌─────────┐ │
│  │ LangGraph    │   │   Redis      │   │ Postgres│ │
│  │ Server       │   │  (消息队列)   │   │ (数据库)│ │
│  │ (API服务器)   │←→│  (缓存)      │←→│ (存储)  │ │
│  └──────────────┘   └──────────────┘   └─────────┘ │
│         ↑                                             │
│         │ HTTP/WebSocket                             │
│         ↓                                             │
│  ┌──────────────────────────────────────────┐        │
│  │         客户端应用                        │        │
│  │  (Web, Mobile, Desktop, CLI...)         │        │
│  └──────────────────────────────────────────┘        │
└──────────────────────────────────────────────────────┘
```

### 1.4 学习目标

通过本节学习，你将掌握：

1. **理解部署所需的文件结构**
   - langgraph.json（配置文件）
   - task_maistro.py（图的实现）
   - requirements.txt（依赖管理）
   - .env（环境变量）

2. **使用 LangGraph CLI**
   - 安装和基本命令
   - 构建 Docker 镜像

3. **Docker 和容器化**
   - Docker 镜像 vs 容器
   - docker-compose 管理多容器

4. **自托管部署流程**
   - 端到端的部署步骤
   - 服务启动和验证

### 1.5 为什么需要学习部署？

**开发 vs 生产的差异：**

| 方面 | 开发环境 | 生产环境 |
|------|---------|---------|
| **数据持久化** | InMemoryStore | PostgreSQL |
| **并发处理** | 单用户 | 多用户并发 |
| **可靠性** | 可以重启 | 需要高可用 |
| **访问方式** | 本地代码调用 | HTTP API |
| **监控** | print() 调试 | 日志和监控系统 |
| **扩展性** | 单机运行 | 可以水平扩展 |

---

## 二、部署所需的代码结构

### 2.1 必需的文件

LangGraph Platform 部署需要以下文件：

```
module-6/deployment/
├── langgraph.json          # LangGraph 配置文件
├── task_maistro.py         # 图的实现代码
├── requirements.txt        # Python 依赖
├── .env                    # 环境变量（不提交到 git）
└── docker-compose.yml      # Docker 容器编排
```

### 2.2 langgraph.json - 配置文件

**作用**：告诉 LangGraph Server 如何找到和运行你的图。

**典型内容**：
```json
{
  "dependencies": [".", "./packages/*"],
  "graphs": {
    "task_maistro": "./task_maistro.py:graph"
  },
  "env": ".env"
}
```

**字段说明**：

| 字段 | 说明 | 示例值 |
|------|------|--------|
| `dependencies` | Python 包的位置 | `[".", "./packages/*"]` |
| `graphs` | 图的名称和位置 | `{"task_maistro": "./task_maistro.py:graph"}` |
| `env` | 环境变量文件 | `.env` |

**Python 知识点 - 模块路径格式**：
```python
"./task_maistro.py:graph"
#  ^^^^^^^^^^^^^^^^  ^^^^^
#       文件路径      变量名
#
# 表示：从 task_maistro.py 文件中导入 graph 变量
#
# 等价于 Python 代码：
# from task_maistro import graph
```

### 2.3 task_maistro.py - 图的实现

**作用**：包含你的 LangGraph 应用的完整实现。

**关键点**：
- 必须导出一个编译后的图（通常命名为 `graph`）
- 包含所有节点、边、状态定义
- 配置 checkpointer 和 store

**示例结构**：
```python
from langgraph.graph import StateGraph, START, END
from langgraph.checkpoint.memory import MemorySaver
from langgraph.store.memory import InMemoryStore

# ... 定义节点函数 ...

# 构建图
builder = StateGraph(MessagesState)
builder.add_node("call_model", call_model)
# ... 添加更多节点和边 ...

# 编译图
checkpointer = MemorySaver()
store = InMemoryStore()
graph = builder.compile(checkpointer=checkpointer, store=store)
```

**重要**：在生产环境中，`MemorySaver` 和 `InMemoryStore` 会被自动替换为 PostgreSQL 和 Redis，无需修改代码！

### 2.4 requirements.txt - 依赖管理

**作用**：声明应用所需的 Python 包和版本。

**典型内容**：
```txt
langgraph>=0.2.0
langchain-openai>=0.2.0
langchain-core>=0.3.0
trustcall>=0.1.0
pydantic>=2.0.0
```

**版本号语法**：

| 语法 | 含义 | 示例 |
|------|------|------|
| `==1.0.0` | 精确版本 | 只安装 1.0.0 |
| `>=1.0.0` | 最小版本 | 1.0.0 或更高 |
| `>=1.0,<2.0` | 版本范围 | 1.x 系列 |
| `~=1.2.3` | 兼容版本 | >=1.2.3, <1.3.0 |

**生成 requirements.txt**：
```bash
# 方法 1：手动编写（推荐用于生产）
# 只列出直接依赖，精确指定版本

# 方法 2：从当前环境导出
pip freeze > requirements.txt

# 方法 3：使用 pipreqs 分析代码
pip install pipreqs
pipreqs /path/to/project
```

### 2.5 .env - 环境变量

**作用**：存储敏感信息（API 密钥等）和配置参数。

**典型内容**：
```bash
# API 密钥
OPENAI_API_KEY=sk-...
LANGSMITH_API_KEY=ls__...

# 可选：自定义配置
DATABASE_URI=postgresql://...
REDIS_URI=redis://...
```

**安全最佳实践**：
```bash
# ❌ 不要做
git add .env                    # 不要提交 .env 到 git
print(os.getenv('OPENAI_API_KEY'))  # 不要打印密钥

# ✅ 应该做
echo ".env" >> .gitignore       # 将 .env 加入 .gitignore
use_api_key = os.getenv('OPENAI_API_KEY')  # 使用环境变量
```

### 2.6 docker-compose.yml - 容器编排

**作用**：定义和管理多个 Docker 容器。

**典型内容**：
```yaml
version: '3.8'
services:
  langgraph-redis:
    image: redis:7
    ports:
      - "6379:6379"

  langgraph-postgres:
    image: postgres:16
    environment:
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"

  langgraph-api:
    image: ${IMAGE_NAME}
    env_file: .env
    ports:
      - "8123:8000"
    depends_on:
      - langgraph-redis
      - langgraph-postgres
```

**服务说明**：

| 服务 | 作用 | 端口 |
|------|------|------|
| `langgraph-redis` | 消息队列和缓存 | 6379 |
| `langgraph-postgres` | 数据持久化 | 5432 |
| `langgraph-api` | LangGraph Server | 8123 → 8000 |

---

## 三、LangGraph CLI

### 3.1 什么是 CLI？

**CLI (Command Line Interface)** = 命令行界面

**LangGraph CLI** 是一个命令行工具，用于：
- 构建 Docker 镜像
- 本地测试部署
- 管理部署配置

### 3.2 安装 LangGraph CLI

```python
%%capture --no-stderr
%pip install -U langgraph-cli
```

**命令解析**：
- `%pip`：Jupyter 魔法命令，在 notebook 中运行 pip
- `install`：安装包
- `-U` / `--upgrade`：升级到最新版本
- `langgraph-cli`：包名

**验证安装**：
```bash
$ langgraph --version
langgraph-cli version 0.1.0
```

### 3.3 LangGraph CLI 常用命令

```bash
# 构建 Docker 镜像
langgraph build -t <image-name>

# 本地运行（开发模式）
langgraph dev

# 查看配置
langgraph config

# 查看帮助
langgraph --help
```

---

## 四、构建 Docker 镜像

### 4.1 什么是 Docker？

**Docker** 是一个容器化平台，可以将应用和所有依赖打包在一起。

**核心概念**：

```
Docker 镜像 (Image)              Docker 容器 (Container)
     ↓                                 ↓
    模板                               实例
    类（Class）                        对象（Object）
    食谱                               做好的菜

    一次构建                          多次运行
    只读                               可读写
```

**为什么使用 Docker？**

| 问题 | 没有 Docker | 有 Docker |
|------|------------|----------|
| 环境不一致 | "在我机器上能跑" | "在任何地方都能跑" |
| 依赖冲突 | Python 版本冲突 | 隔离的环境 |
| 部署复杂 | 需要手动配置 | 一键部署 |
| 扩展困难 | 需要配置新机器 | 启动新容器 |

### 4.2 构建 LangGraph Server 镜像

**步骤 1：进入部署目录**
```bash
$ cd module-6/deployment
```

**步骤 2：构建镜像**
```bash
$ langgraph build -t my-image
```

**命令解析**：
- `langgraph build`：构建 Docker 镜像
- `-t my-image`：给镜像打标签（tag），名字是 `my-image`
- LangGraph CLI 会自动：
  1. 读取 `langgraph.json` 配置
  2. 找到图的代码（`task_maistro.py`）
  3. 安装 `requirements.txt` 中的依赖
  4. 打包成 Docker 镜像

**构建过程输出示例**：
```
Building LangGraph Cloud API server Docker image...
[+] Building 45.2s (12/12) FINISHED
 => [internal] load build definition from Dockerfile
 => [internal] load .dockerignore
 => [1/6] FROM docker.io/library/python:3.11-slim
 => [2/6] WORKDIR /app
 => [3/6] COPY requirements.txt .
 => [4/6] RUN pip install -r requirements.txt
 => [5/6] COPY . .
 => [6/6] RUN pip install -e .
 => exporting to image
 => => naming to docker.io/library/my-image
```

**验证镜像**：
```bash
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
my-image     latest    abc123def456   2 minutes ago    1.2GB
```

### 4.3 Docker 镜像的内容

Docker 镜像包含：

1. **基础系统**：Python 3.11 运行环境
2. **应用代码**：task_maistro.py 等文件
3. **依赖包**：requirements.txt 中的所有包
4. **LangGraph Server**：HTTP API 服务器
5. **启动脚本**：自动启动服务的命令

**镜像分层结构**：
```
┌─────────────────────────────┐  ← my-image (你的应用)
├─────────────────────────────┤
│  task_maistro.py           │
│  langgraph.json            │
│  requirements.txt          │
├─────────────────────────────┤  ← Python 包层
│  langgraph==0.2.0          │
│  langchain-openai==0.2.0   │
│  ...                       │
├─────────────────────────────┤  ← Python 运行时
│  Python 3.11               │
├─────────────────────────────┤  ← 基础操作系统
│  Debian Linux (slim)       │
└─────────────────────────────┘
```

---

## 五、设置 Redis 和 PostgreSQL

### 5.1 为什么需要 Redis 和 PostgreSQL？

**开发 vs 生产的存储差异**：

| 组件 | 开发环境 | 生产环境 |
|------|---------|---------|
| **Checkpointer** | MemorySaver (内存) | PostgreSQL (数据库) |
| **Store** | InMemoryStore (内存) | PostgreSQL (数据库) |
| **消息队列** | 无 | Redis |

**为什么需要它们？**

**PostgreSQL（数据持久化）**：
- 保存对话历史（threads）
- 保存检查点（checkpoints）
- 保存长期记忆（store）
- 数据不会因重启而丢失

**Redis（缓存和队列）**：
- 流式传输（streaming）的中间结果
- 任务队列（background runs）
- 会话缓存
- 高性能读写

### 5.2 方案一：使用已有的 Redis 和 PostgreSQL

如果你已经有运行的 Redis 和 PostgreSQL 服务器：

```bash
docker run \
    --env-file .env \
    -p 8123:8000 \
    -e REDIS_URI="redis://your-redis-server:6379" \
    -e DATABASE_URI="postgresql://user:pass@your-postgres:5432/db" \
    -e LANGSMITH_API_KEY="your-api-key" \
    my-image
```

**命令解析**：
- `docker run`：运行容器
- `--env-file .env`：加载 .env 文件中的环境变量
- `-p 8123:8000`：端口映射（主机8123 → 容器8000）
- `-e KEY=VALUE`：设置环境变量
- `my-image`：使用的镜像名

**端口映射详解**：
```
-p 8123:8000
   ^^^^  ^^^^
   主机  容器
   端口  端口

访问: http://localhost:8123
  ↓
映射到容器内的: http://container:8000
```

### 5.3 方案二：使用 docker-compose 一键启动

**推荐方案**：使用 docker-compose 同时管理三个容器。

**步骤 1：准备配置文件**
```bash
# 复制示例文件
$ cp docker-compose-example.yml docker-compose.yml

# 编辑配置
$ nano docker-compose.yml
```

**步骤 2：设置环境变量**

创建或编辑 `.env` 文件：
```bash
# 镜像名称（你刚才构建的）
IMAGE_NAME=my-image

# API 密钥
LANGSMITH_API_KEY=ls__your-key-here
OPENAI_API_KEY=sk-your-key-here
```

**步骤 3：启动所有服务**
```bash
$ cd module-6/deployment
$ docker compose up
```

**启动过程输出**：
```
[+] Running 3/3
 ✔ Container deployment-langgraph-redis-1     Started
 ✔ Container deployment-langgraph-postgres-1  Started
 ✔ Container deployment-langgraph-api-1       Started

langgraph-api-1     | INFO:     Started server process
langgraph-api-1     | INFO:     Waiting for application startup.
langgraph-api-1     | INFO:     Application startup complete.
langgraph-api-1     | INFO:     Uvicorn running on http://0.0.0.0:8000
```

**验证服务**：
```bash
# 方法 1：浏览器访问
# 打开 http://localhost:8123

# 方法 2：curl 测试
$ curl http://localhost:8123/health
{"status": "ok"}

# 方法 3：查看 API 文档
# 打开 http://localhost:8123/docs
```

### 5.4 docker-compose 详解

**docker-compose.yml 结构**：
```yaml
version: '3.8'

services:
  # 服务 1：Redis
  langgraph-redis:
    image: redis:7                # 使用官方 Redis 镜像
    healthcheck:                  # 健康检查
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 1s
      retries: 5

  # 服务 2：PostgreSQL
  langgraph-postgres:
    image: postgres:16            # 使用官方 Postgres 镜像
    environment:
      POSTGRES_DB: langgraph
      POSTGRES_USER: langgraph
      POSTGRES_PASSWORD: langgraph

  # 服务 3：LangGraph API
  langgraph-api:
    image: ${IMAGE_NAME}          # 使用你构建的镜像
    env_file: .env                # 加载环境变量
    ports:
      - "8123:8000"               # 端口映射
    depends_on:                   # 依赖关系
      - langgraph-redis
      - langgraph-postgres
    environment:
      REDIS_URI: redis://langgraph-redis:6379
      POSTGRES_URI: postgresql://langgraph:langgraph@langgraph-postgres:5432/langgraph
```

**服务依赖关系**：
```
langgraph-api
    ↓ depends_on
    ├→ langgraph-redis    (必须先启动)
    └→ langgraph-postgres (必须先启动)
```

**网络通信**：
```
Docker 内部网络（自动创建）
┌─────────────────────────────────────────┐
│  langgraph-redis                        │
│  (hostname: langgraph-redis)            │
│  (port: 6379)                          │
├─────────────────────────────────────────┤
│  langgraph-postgres                     │
│  (hostname: langgraph-postgres)         │
│  (port: 5432)                          │
├─────────────────────────────────────────┤
│  langgraph-api                          │
│  (可以通过主机名访问其他服务)             │
│  (内部端口: 8000)                       │
└─────────────────────────────────────────┘
         ↓ 端口映射
    localhost:8123 (外部访问)
```

---

## 六、启动和验证部署

### 6.1 启动部署

**前台运行**（查看日志）：
```bash
$ docker compose up
```
- 会占用终端
- 实时显示日志
- Ctrl+C 停止

**后台运行**（守护进程）：
```bash
$ docker compose up -d
```
- 释放终端
- 日志写入文件
- 需要手动停止

### 6.2 查看服务状态

```bash
# 查看运行的容器
$ docker compose ps

NAME                              STATUS    PORTS
deployment-langgraph-api-1        Up        0.0.0.0:8123->8000/tcp
deployment-langgraph-postgres-1   Up        0.0.0.0:5432->5432/tcp
deployment-langgraph-redis-1      Up        0.0.0.0:6379->6379/tcp
```

### 6.3 查看日志

```bash
# 查看所有服务的日志
$ docker compose logs

# 查看特定服务的日志
$ docker compose logs langgraph-api

# 实时跟踪日志
$ docker compose logs -f langgraph-api
```

### 6.4 访问部署

部署成功后，你可以通过以下方式访问：

**1. API 端点**：
```
http://localhost:8123
```

**2. API 文档（Swagger UI）**：
```
http://localhost:8123/docs
```
- 交互式 API 文档
- 可以直接测试 API
- 查看所有可用端点

**3. LangGraph Studio**：
```
https://smith.langchain.com/studio/?baseUrl=http://127.0.0.1:8123
```
- 可视化图编辑器
- 调试和监控
- 查看运行历史

### 6.5 测试 API

**测试健康检查**：
```bash
$ curl http://localhost:8123/health
{"status": "ok"}
```

**测试图列表**：
```bash
$ curl http://localhost:8123/graphs
[
  {
    "graph_id": "task_maistro",
    "name": "task_maistro",
    "description": null
  }
]
```

**使用 Python SDK 测试**：
```python
from langgraph_sdk import get_client

# 连接到部署
client = get_client(url="http://localhost:8123")

# 创建线程
thread = await client.threads.create()
print(thread)
```

### 6.6 停止和清理

**停止所有服务**：
```bash
$ docker compose down
```

**停止并删除数据卷**：
```bash
$ docker compose down -v
```
- 会删除 PostgreSQL 中的所有数据
- 谨慎使用！

**重启服务**：
```bash
$ docker compose restart
```

---

## 七、部署架构深入理解

### 7.1 LangGraph Server 架构

```
                  客户端请求
                      ↓
              ┌──────────────┐
              │   HTTP API   │
              │  (Port 8123) │
              └──────────────┘
                      ↓
         ┌────────────┴────────────┐
         ↓                         ↓
    ┌─────────┐              ┌─────────┐
    │  HTTP   │              │  Queue  │
    │ Worker  │              │ Worker  │
    └─────────┘              └─────────┘
         ↓                         ↓
         └────────┬─────────┬──────┘
                  ↓         ↓
           ┌──────────┐  ┌──────────┐
           │  Redis   │  │Postgres  │
           │ (缓存)   │  │ (存储)   │
           └──────────┘  └──────────┘
```

**组件说明**：

**HTTP Worker**：
- 处理客户端请求
- 管理 WebSocket 连接
- 流式传输结果
- 返回响应

**Queue Worker**：
- 执行图的运行
- 处理后台任务
- 管理长时间运行的任务
- 写入结果到数据库

**Redis**：
- 任务队列
- 流式传输缓存
- 会话缓存
- 发布/订阅

**PostgreSQL**：
- 线程（threads）
- 运行历史（runs）
- 检查点（checkpoints）
- Store 数据

### 7.2 请求处理流程

**同步请求流程**：
```
1. 客户端发送请求
   ↓
2. HTTP Worker 接收
   ↓
3. Queue Worker 开始执行图
   ↓
4. 图执行完成
   ↓
5. 结果写入 PostgreSQL
   ↓
6. HTTP Worker 返回结果
```

**流式请求流程**：
```
1. 客户端发送流式请求
   ↓
2. HTTP Worker 建立 WebSocket
   ↓
3. Queue Worker 开始执行
   ↓
4. 执行过程中发布更新到 Redis
   ↓
5. HTTP Worker 从 Redis 订阅
   ↓
6. 实时推送给客户端
   ↓
7. 执行完成，关闭连接
```

### 7.3 数据持久化

**开发环境**：
```python
# 内存存储（重启丢失）
checkpointer = MemorySaver()
store = InMemoryStore()
```

**生产环境**：
```python
# 自动使用 PostgreSQL（持久化）
# 无需修改代码！
checkpointer = PostgresSaver()  # 自动
store = PostgresStore()         # 自动
```

**数据表结构**：
```sql
-- threads 表：对话线程
CREATE TABLE threads (
    thread_id TEXT PRIMARY KEY,
    created_at TIMESTAMP,
    metadata JSONB
);

-- checkpoints 表：状态检查点
CREATE TABLE checkpoints (
    thread_id TEXT,
    checkpoint_id TEXT,
    parent_checkpoint_id TEXT,
    type TEXT,
    checkpoint JSONB,
    PRIMARY KEY (thread_id, checkpoint_id)
);

-- store 表：长期记忆
CREATE TABLE store (
    namespace TEXT[],
    key TEXT,
    value JSONB,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    PRIMARY KEY (namespace, key)
);
```

---

## 八、常见问题和解决方案

### 8.1 构建镜像失败

**问题**：
```
ERROR: failed to solve: failed to compute cache key
```

**解决方案**：
```bash
# 1. 确保 Docker 正在运行
$ docker ps

# 2. 清理 Docker 缓存
$ docker system prune -a

# 3. 重新构建
$ langgraph build -t my-image --no-cache
```

### 8.2 端口已被占用

**问题**：
```
Error: bind: address already in use
```

**解决方案**：
```bash
# 查找占用端口的进程
$ lsof -i :8123

# 杀死进程
$ kill -9 <PID>

# 或者修改 docker-compose.yml 中的端口
ports:
  - "8124:8000"  # 改用 8124 端口
```

### 8.3 环境变量未加载

**问题**：API 密钥未生效

**检查清单**：
1. `.env` 文件是否存在？
2. `.env` 文件格式是否正确？
3. `docker-compose.yml` 中是否指定了 `env_file: .env`？
4. 是否重启了容器？

**解决方案**：
```bash
# 验证环境变量
$ docker compose config

# 重启容器以加载新的环境变量
$ docker compose down
$ docker compose up
```

### 8.4 数据库连接失败

**问题**：
```
Could not connect to database
```

**解决方案**：
```bash
# 1. 检查 PostgreSQL 是否启动
$ docker compose ps langgraph-postgres

# 2. 查看 PostgreSQL 日志
$ docker compose logs langgraph-postgres

# 3. 验证数据库连接字符串
# 在 docker-compose.yml 中检查 POSTGRES_URI
```

### 8.5 Redis 连接失败

**问题**：
```
Could not connect to Redis
```

**解决方案**：
```bash
# 1. 检查 Redis 是否启动
$ docker compose ps langgraph-redis

# 2. 测试 Redis 连接
$ docker exec -it deployment-langgraph-redis-1 redis-cli ping
PONG

# 3. 检查 REDIS_URI 配置
```

---

## 九、部署最佳实践

### 9.1 开发工作流

**推荐流程**：
```
1. 本地开发和测试
   ↓
2. 构建 Docker 镜像
   ↓
3. 本地测试部署（docker-compose）
   ↓
4. 部署到测试环境
   ↓
5. 部署到生产环境
```

### 9.2 版本管理

**镜像版本标记**：
```bash
# 开发版本
langgraph build -t my-image:dev

# 测试版本
langgraph build -t my-image:test

# 生产版本
langgraph build -t my-image:v1.0.0
langgraph build -t my-image:latest
```

### 9.3 环境分离

**多环境配置**：
```
project/
├── .env.development    # 开发环境
├── .env.test          # 测试环境
├── .env.production    # 生产环境
└── docker-compose.yml
```

**使用不同环境**：
```bash
# 开发环境
$ cp .env.development .env
$ docker compose up

# 生产环境
$ cp .env.production .env
$ docker compose up
```

### 9.4 监控和日志

**日志管理**：
```bash
# 持续查看日志
$ docker compose logs -f

# 保存日志到文件
$ docker compose logs > deployment.log

# 使用日志聚合工具（生产环境）
# - ELK Stack (Elasticsearch, Logstash, Kibana)
# - Grafana Loki
# - CloudWatch (AWS)
```

### 9.5 备份和恢复

**备份 PostgreSQL 数据**：
```bash
# 备份
$ docker exec deployment-langgraph-postgres-1 \
  pg_dump -U langgraph langgraph > backup.sql

# 恢复
$ docker exec -i deployment-langgraph-postgres-1 \
  psql -U langgraph langgraph < backup.sql
```

---

## 十、Python 和 Docker 知识总结

### 10.1 Docker 基础命令

```bash
# 镜像管理
docker images                    # 列出镜像
docker rmi <image-id>           # 删除镜像
docker pull <image-name>        # 拉取镜像

# 容器管理
docker ps                        # 列出运行的容器
docker ps -a                     # 列出所有容器
docker stop <container-id>      # 停止容器
docker rm <container-id>        # 删除容器
docker exec -it <container> sh  # 进入容器

# docker-compose
docker compose up               # 启动服务
docker compose down             # 停止服务
docker compose ps               # 查看服务状态
docker compose logs             # 查看日志
docker compose restart          # 重启服务
```

### 10.2 端口和网络

**端口映射格式**：
```
-p <host-port>:<container-port>
    主机端口    容器端口

示例：
-p 8123:8000
  ^^^^  ^^^^
  外部  内部
```

**网络通信**：
```python
# 容器内访问其他容器
# 使用服务名作为主机名
redis_url = "redis://langgraph-redis:6379"
postgres_url = "postgresql://langgraph-postgres:5432"

# 主机访问容器
# 使用 localhost 和映射的端口
api_url = "http://localhost:8123"
```

### 10.3 环境变量处理

**Python 读取环境变量**：
```python
import os

# 方法 1：使用 os.getenv（推荐）
api_key = os.getenv('OPENAI_API_KEY')
# 如果不存在，返回 None

# 方法 2：使用 os.getenv 带默认值
api_key = os.getenv('OPENAI_API_KEY', 'default-key')

# 方法 3：使用 os.environ（不推荐）
api_key = os.environ['OPENAI_API_KEY']
# 如果不存在，会抛出 KeyError
```

**加载 .env 文件**：
```python
from dotenv import load_dotenv
import os

# 加载 .env 文件
load_dotenv()

# 现在可以读取环境变量了
api_key = os.getenv('OPENAI_API_KEY')
```

---

## 十一、下一步

### 11.1 本节回顾

你已经学会了：
- ✅ 理解 LangGraph 部署的文件结构
- ✅ 使用 LangGraph CLI 构建 Docker 镜像
- ✅ 使用 docker-compose 管理多容器部署
- ✅ 启动和验证自托管部署
- ✅ 理解 LangGraph Platform 的架构

### 11.2 下节预告

在 **6.2-connecting** 中，我们将学习：
- 使用 LangGraph SDK 连接到部署
- Remote Graph 的使用
- Runs 和 Threads 的管理
- Store API 的操作
- 流式传输和后台运行

### 11.3 进阶学习

**云平台部署**：
- AWS ECS/Fargate
- Google Cloud Run
- Azure Container Instances
- Kubernetes

**生产环境优化**：
- 负载均衡
- 自动扩展
- 高可用配置
- 安全加固

---

## 十二、总结

### 12.1 核心要点

1. **部署 = 让应用在生产环境运行**
   - 需要持久化存储（PostgreSQL）
   - 需要缓存和队列（Redis）
   - 需要容器化（Docker）

2. **必需的文件**
   - `langgraph.json`：配置
   - `task_maistro.py`：代码
   - `requirements.txt`：依赖
   - `.env`：环境变量
   - `docker-compose.yml`：编排

3. **部署流程**
   ```
   编写代码 → 构建镜像 → 启动服务 → 验证运行
   ```

4. **LangGraph Platform 架构**
   ```
   Client → HTTP Worker → Queue Worker
                ↓              ↓
              Redis      PostgreSQL
   ```

### 12.2 关键命令速查

```bash
# 构建镜像
langgraph build -t my-image

# 启动部署
docker compose up

# 查看状态
docker compose ps

# 查看日志
docker compose logs -f

# 停止部署
docker compose down
```

### 12.3 最佳实践

- ✅ 使用版本标记管理镜像
- ✅ 不要提交 .env 到 git
- ✅ 定期备份 PostgreSQL 数据
- ✅ 监控日志和性能
- ✅ 使用环境分离（dev/test/prod）

---

**文档版本**：1.0
**最后更新**：2024-11-05
**作者**：AI Assistant
**基于**：LangChain Academy Module-6 Lesson 6.1

恭喜你迈出了 LangGraph 生产部署的第一步！🎉 现在你已经知道如何将应用部署到生产环境了。接下来让我们学习如何连接和使用这个部署。
